"""
Multi-Platform Social Media Archive Bot
Enhanced to support Twitter, Instagram, Facebook, TikTok, and future platforms
"""

import asyncio
import logging
import os
import json
from datetime import datetime
from aiohttp import web
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from dotenv import load_dotenv
from twscrape import API
import sys

# Add parent directory to path for platform manager
sys.path.append('..')

from bot.platform_manager import PlatformManager
from bot.url_detector import URLDetector
from core.data_models import UserContext

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class MultiPlatformBot:
    def __init__(self):
        # Initialize Telegram bot
        bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            raise ValueError("TELEGRAM_BOT_TOKEN not found in environment variables")
        
        self.application = Application.builder().token(bot_token).build()
        
        # Initialize platform manager and URL detector
        self.platform_manager = PlatformManager()
        self.url_detector = URLDetector()
        
        # Initialize Twitter API for traditional tweets
        self.twscrape_api = API()
        
        # Setup handlers
        self._setup_handlers()
        
        # Webhook configuration
        self.webhook_url = os.getenv('WEBHOOK_URL', 'https://ov-ab103a.infomaniak.ch/webhook')
        self.webhook_port = int(os.getenv('WEBHOOK_PORT', 8443))
        
        logger.info("Multi-platform bot initialized")

    def _setup_handlers(self):
        """Set up Telegram command and message handlers"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("platforms", self.platforms_command))
        
        # Message handlers
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        welcome_message = """
ü§ñ **Multi-Platform Social Media Archive Bot**

Welcome! I can archive content from multiple social media platforms.

**Supported Platforms:**
üê¶ Twitter/X
üì∏ Instagram
üìò Facebook (coming soon)
üéµ TikTok (coming soon)

**How to use:**
Just send me a social media URL and I'll archive it for you!

**Commands:**
/help - Show detailed help
/platforms - List supported platforms

Ready to archive! üìö
"""
        await update.message.reply_text(welcome_message, parse_mode='Markdown')

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = """
üìö **Multi-Platform Archive Bot Help**

**Supported URL formats:**

üê¶ **Twitter/X:**
‚Ä¢ https://twitter.com/user/status/123...
‚Ä¢ https://x.com/user/status/123...

üì∏ **Instagram:**
‚Ä¢ https://instagram.com/p/ABC123/
‚Ä¢ https://instagram.com/reel/ABC123/

**Features:**
‚úÖ Full content archival
‚úÖ Media download
‚úÖ Metadata extraction
‚úÖ User attribution
‚úÖ Hashtag extraction

**Usage:**
1. Send me a supported URL
2. Add hashtags if desired (e.g., #important #research)
3. I'll archive the content and provide download links

**Storage:**
‚Ä¢ JSON data: Structured metadata
‚Ä¢ Media files: Original quality when possible
‚Ä¢ Web access: View archived content online

Need more help? Contact the administrator.
"""
        await update.message.reply_text(help_message, parse_mode='Markdown')

    async def platforms_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /platforms command"""
        platforms = self.platform_manager.get_supported_platforms()
        platform_list = "\n".join([f"‚Ä¢ {platform.value.title()}" for platform in platforms])
        
        message = f"""
üåê **Supported Platforms**

{platform_list}

**Status:** All platforms active and ready for archival!

Send me a URL from any supported platform to get started.
"""
        await update.message.reply_text(message, parse_mode='Markdown')

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle incoming messages with URLs"""
        try:
            message_text = update.message.text
            chat_id = update.message.chat_id
            user_id = update.message.from_user.id
            username = update.message.from_user.username or f"user_{user_id}"
            
            logger.info(f"Processing message from {username} (ID: {user_id})")
            logger.info(f"Message: {message_text}")
            
            # Detect URLs and extract hashtags
            urls = self.url_detector.extract_urls(message_text)
            hashtags = self.url_detector.extract_hashtags(message_text)
            
            if not urls:
                await update.message.reply_text(
                    "üîó Please send me a social media URL to archive!\n\n"
                    "Supported platforms: Twitter, Instagram\n"
                    "Use /help for more information."
                )
                return

            # Process each URL
            for url in urls:
                await self._process_url(update, url, hashtags, user_id, username)

        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await update.message.reply_text(
                "‚ùå Sorry, an error occurred while processing your message. Please try again."
            )

    async def _process_url(self, update: Update, url: str, user_hashtags: list, user_id: int, username: str):
        """Process a single URL"""
        try:
            # Detect platform
            platform = self.url_detector.detect_platform(url)
            
            if not platform:
                await update.message.reply_text(f"‚ùå Unsupported URL: {url}")
                return

            # Create user context
            user_context = UserContext(
                telegram_user_id=user_id,
                telegram_username=username
            )

            # Send processing message
            processing_msg = await update.message.reply_text(
                f"‚è≥ Processing {platform} content...\n\n"
                f"üîó URL: {url}\n"
                f"üìä Platform: {platform.value.title()}\n"
                f"üë§ User: @{username}"
            )

            logger.info(f"   üéØ Platform detected: {platform}")
            logger.info(f"   üîó URL: {url}")
            logger.info(f"   #Ô∏è‚É£ Hashtags: {user_hashtags}")
            logger.info(f"   üöÄ Starting {platform} scraping...")

            # Scrape content using platform manager
            try:
                post_data = await self.platform_manager.scrape_url(url, user_context)
                
                if not post_data:
                    await self._send_error_response(update, platform, "No data retrieved", processing_msg)
                    return

                # Store hashtags
                if user_hashtags:
                    post_data['user_hashtags'] = user_hashtags

                # Send success response with detailed format
                await self._send_success_response(update, platform, post_data, user_hashtags, processing_msg)

            except Exception as scraping_error:
                logger.error(f"Scraping error: {scraping_error}")
                await self._send_error_response(update, platform, str(scraping_error), processing_msg)

        except Exception as e:
            logger.error(f"Error processing URL {url}: {e}")
            await update.message.reply_text(f"‚ùå Error processing {url}: {str(e)}")

    async def _send_success_response(self, update: Update, platform: str, post_data: dict, user_hashtags: list, processing_msg):
        """Send detailed success response matching expected format"""
        try:
            # Extract data safely
            author_data = post_data.get('author', {})
            author_username = author_data.get('username', 'Unknown')
            author_name = author_data.get('display_name', 'Unknown')
            post_id = post_data.get('id', 'Unknown')
            tweet_text = post_data.get('text', '')
            created_at = post_data.get('created_at', 'Unknown')
            
            # Get metrics
            metrics = post_data.get('metrics', {})
            likes = metrics.get('likes', 0)
            retweets = metrics.get('retweets', 0) or metrics.get('shares', 0)
            replies = metrics.get('replies', 0) or metrics.get('comments', 0)
            
            # Prepare text display
            if len(tweet_text) > 100:
                display_text = tweet_text[:100] + "..."
            else:
                display_text = tweet_text
            
            # Build response parts
            response_parts = [
                "‚úÖ Tweet scraped successfully!" if platform == 'twitter' else f"‚úÖ {platform.value.title()} scraped successfully!",
                "",
                f"üë§ Author: @{author_username} ({author_name})",
                f"üìÖ Date: {created_at}",
                f"üëç Likes: {likes} | üîÑ Retweets: {retweets} | üí¨ Replies: {replies}",
                "",
                f"Text: {display_text}",
                "",
            ]
            
            # Add media download links if available
            media_items = post_data.get('media', [])
            if media_items:
                media_links = []
                for i, media in enumerate(media_items):
                    media_url = media.get('url')
                    if media_url:
                        media_type = media.get('type', 'media').lower()
                        if media_type in ['photo', 'image']:
                            icon = "üñºÔ∏è"
                        elif media_type in ['video', 'animated_gif']:
                            icon = "üé•"
                        else:
                            icon = "üìé"
                        media_links.append(f"{icon} [Download {media_type.title()} {i+1}]({media_url})")
                
                if media_links:
                    response_parts.extend([
                        "",
                        "üì• Media Downloads:"
                    ])
                    response_parts.extend([f"  {link}" for link in media_links])
            
            # Add JSON storage link
            response_parts.extend([
                "",
                f"üíæ Saved to: https://ov-ab103a.infomaniak.ch/data/tweet_{post_id}.json"
            ])
            
            # Join response parts
            response_text = "\n".join(response_parts)
            
            # Send response
            await processing_msg.edit_text(response_text, parse_mode='Markdown', disable_web_page_preview=True)
            
        except Exception as e:
            logger.error(f"Error sending detailed success response: {e}")
            # Fallback to simple message
            simple_message = f"‚úÖ {platform.value.title()} content archived successfully!\n\nPost ID: {post_data.get('id', 'Unknown')}\nAuthor: {post_data.get('author', {}).get('display_name', 'Unknown')}"
            await processing_msg.edit_text(simple_message)

    async def _send_error_response(self, update: Update, platform, error, processing_msg):
        """Send error response"""
        error_message = f"""‚ùå **{platform.value.title()} Archive Failed**

**Error:** {error}

**üîß What you can try:**
‚Ä¢ Check if the URL is accessible and public
‚Ä¢ Try again in a few minutes (rate limiting)
‚Ä¢ Ensure the post still exists

**üí° Need help?** Send /help for supported formats."""
        
        try:
            await processing_msg.edit_text(error_message, parse_mode='Markdown')
        except Exception:
            # Fallback without markdown
            simple_error = f"‚ùå {platform.value.title()} Archive Failed\n\nError: {error}\n\nTry again later or contact support."
            await processing_msg.edit_text(simple_error)

    async def webhook_handler(self, request):
        """Handle incoming webhook requests"""
        try:
            body = await request.text()
            update = Update.de_json(json.loads(body), self.application.bot)
            await self.application.process_update(update)
            return web.Response(text="OK")
        except Exception as e:
            logger.error(f"Webhook error: {e}")
            return web.Response(text="Error", status=500)

    async def start_bot(self):
        """Start the bot in webhook mode"""
        logger.info("Starting bot in WEBHOOK mode")
        
        # Initialize application
        await self.application.initialize()
        await self.application.start()
        
        # Set webhook
        await self.application.bot.set_webhook(url=self.webhook_url)
        logger.info(f"Webhook set to: {self.webhook_url}")
        
        # Create web app
        app = web.Application()
        app.router.add_post('/webhook', self.webhook_handler)
        
        # Start web server
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', self.webhook_port)
        await site.start()
        
        logger.info(f"Webhook server started on port {self.webhook_port}")
        
        # Get supported platforms
        platforms = self.platform_manager.get_supported_platforms()
        logger.info(f"Multi-platform support: {', '.join(platforms)}")
        
        # Keep running
        while True:
            await asyncio.sleep(1)

async def main():
    """Main function"""
    bot = MultiPlatformBot()
    await bot.start_bot()

if __name__ == "__main__":
    asyncio.run(main())
